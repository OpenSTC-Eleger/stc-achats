-
  tests of open.engagement step
-
  first, i create xml_id for open.engagement created before
-
  !python {model: purchase.order}: |
    po = self.browse(cr, uid, ref('openstc_achats_tests_po1'))
    assert po.engage_id, "open.engagement is not created, check create_engage method"
    values = {}
    self.pool.get("ir.model.data").create(cr, uid, {'module':'openstc_achat_stock','model':'open.engagement','name':'openstc_achats_tests_open_engagement1','res_id':po.engage_id.id,'no_update':False})
-
  then, i check generation of engagements
-
  !assert {model: open.engagement, id: openstc_achats_tests_open_engagement1, count: 1, severity: error, string: "open.engagement is not correctly created, check create_engage method"}:
    - engage_lines != False
    - len(engage_lines) == 1
    - engage_lines[0].budget_line_id.id == ref('openstc_achats_tests_budget1_line1')
    - engage_lines[0].amount == purchase_order_id.amount_total
-
  then i test dialog between buyer anc accountant service, via pdf invoices attached
-
  first, id add a new pdf invoice by creating ir.attahment record
-
  !python {model: ir.attachment}: |
    import base64
    values = {
    'res_model': 'open.engagement',
    'res_id': ref('openstc_achats_tests_open_engagement1'),
    'company_id': 1,
    'res_name': 'Open Engagements 1',
    'datas_fname': "F-2013-01-01-0001",
    'type': 'binary',
    'datas': base64.b64encode("a"),
    'name': "F-2013-01-01-0001"}
    self.pool.get("ir.model.data")._update(cr, uid,'ir.attachment','openstc_achat_stock',values, 'openstc_achats_tests_attach1', mode='update',noupdate=False)
    
-
  and i check that pdf attaches is considered as invoice
-
  !assert {model: ir.attachment, id: openstc_achats_tests_attach1, severity: error, string: "Attach not considered as invoice, check create overrided method of ir_attachment"}:
    - state == 'to_check'
-
  now, i check buyer treatment of pdf invoices, he cans refuse it or accept it
-
  i check first refusing of invoice, i have to create wizard associated to refusing
-
  !record {model: openstc.open.engage.refuse.inv.wizard, id: openstc_achats_tests_wizard_refuse1}:
    justif_refuse: automatic tests
-
  and i validate the wizard
-  
  !function {model: openstc.open.engage.refuse.inv.wizard, name: to_refuse}:
    - eval: ref('openstc_achats_tests_wizard_refuse1')
      model: openstc.open.engage.refuse.inv.wizard
    - eval: "{'attach_id': ref('openstc_achats_tests_attach1')}"
-
  i check that mail is sent with the text written above
-
  !assert {model: mail.message, search: "[('res_id','=',ref('openstc_achats_tests_open_engagement1')), ('model','=', 'open.engagement'), ('subject', 'like','%refus%')]", count: 1, severity: error, string: "error during generating or sending email, check email.template or refuse_invoice_to_pay method of ir_attachment"}:
    - state == 'sent'
    - body_html.find('automatic tests') != -1
    - body_text.find('automatic tests') != -1
    - attachment_ids != False
    - attachment_ids[0].name == "F-2013-01-01-0001"
-
  and i check if ir_attachment state is to refused
-
  !assert {model: ir.attachment, id: openstc_achats_tests_attach1, severity: error, string: "Attach is not correctly set to refused, check refuse_invoice_to_pay method"}:
    - state == 'refused'
-
  now i make same tests for validated pdf invoice
-
  first, i add a second pdf invoice by creating ir.attahment record
-
  !python {model: ir.attachment}: |
    import base64
    values = {
    'res_model': 'open.engagement',
    'res_id': ref('openstc_achats_tests_open_engagement1'),
    'company_id': 1,
    'res_name': 'Open Engagements 1',
    'datas_fname': "F-2013-01-01-0002",
    'type': 'binary',
    'datas': base64.b64encode("a"),
    'name': "F-2013-01-01-0002"}
    self.pool.get("ir.model.data")._update(cr, uid,'ir.attachment','openstc_achat_stock',values, 'openstc_achats_tests_attach2', mode='update',noupdate=False)
    
-
  and i check that pdf attached is considered as invoice
-
  !assert {model: ir.attachment, id: openstc_achats_tests_attach2, severity: error, string: "Attach not considered as invoice, check create overrided method of ir_attachment"}:
    - state == 'to_check'
-
  now, i check buyer treatment of pdf invoices, he cans refuse it or accept it
-
  i check then validation of invoice
-
  !function {model: ir.attachment, name: send_invoice_to_pay}:
    - eval: ref('openstc_achats_tests_attach2')
      model: ir.attachment
-
  i check that mail is sent
-
  !assert {model: mail.message, search: "[('res_id','=',ref('openstc_achats_tests_open_engagement1')), ('model','=','open.engagement'), ('subject', 'like','%Valid%')]", count: 1, severity: error, string: "error during generating or sending email, check email.template or send_invoice_to_pay method of ir_attachment"}:
    - state == 'sent'
    - attachment_ids != False
    - attachment_ids[0].name == "F-2013-01-01-0002"
-
  and i check if ir_attachment state is to validated
-
  !assert {model: ir.attachment, id: openstc_achats_tests_attach2, severity: error, string: "Attach is not correctly set to validated, check refuse_invoice_to_pay method"}:
    - state == 'validated'
-
  now, i test ending of open.engagement
-
  i force reception_ok to True, because stock.move are not tested for now
-
  !function {model: open.engagement, name: write}:
      - eval: ref('openstc_achats_tests_open_engagement1')
        model: open.engagement
      - eval: "{'reception_ok':True}"
-
  And i check that i can end this open.engagement
-
  !function {model: ir.attachment, name: engage_complete}:
    - eval: ref('openstc_achats_tests_attach2')
      model: ir.attachment
-
  !assert {model: open.engagement, id: openstc_achats_tests_open_engagement1, severity: error, string: "open.engagement not correctly ended, check engage_complete method"}:
    - state == 'done'
-
  finally, i rollback database udpates after all of my tests files are executed
-
  !python {model: open.engagement}: |
    cr.rollback()